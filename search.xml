<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Head First Java 第七章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><ol>
<li><p>了解继承</p>
<p> 子类继承父类的实例变量和方法，子类可以加入自己的实例变量和方法，还可以覆盖继承来的方法。</p>
<p> 当调用对象引用的方法时，会调用到与该对象类型最接近的方法，也就是<strong>最低阶的会胜出</strong>。最低阶的意思就是在层次树的最下方，JVM会从下往上找直到找到为止。</p>
<span id="more"></span></li>
<li><p><code>is-a</code>关系和<code>has-a</code>关系</p>
<p> <code>is-a</code>:代表一种继承关系，是一种单向链式关系</p>
<p> <code>has-a</code>:代表包含关系</p>
</li>
<li><p>在子类中打算引用父类的方法然后再加上额外的行为</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.roam();</span><br><span class="line">    <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用<code>super</code>这个关键词取用父类，这样先执行父类的roam(),然后再执行自定义的行为。<code>super</code>类比于C++里的<code>::</code>。</p>
<p> 相对<code>super</code>,<code>this</code>指向自己的引用。</p>
</li>
<li><p>多态</p>
</li>
</ol>
<ul>
<li>引用类型可以是实际对象的父类</li>
<li>参数和返回类型也可以多态，比如当参数声明为父类类型时，可以传进子类对象，执行子类的方法。</li>
</ul>
<ol start="5">
<li><p>是否有私有类</p>
<p> 除了内部类并没有私有类这个概念，但有三个方法能够限制被继承。</p>
<ul>
<li><p>存取控制</p>
<p>标记为非公有，非公有的类只能被同一个package里的类继承</p>
</li>
<li><p>使用<code>final</code>修饰符，代表该类是继承树末端，无法被继承</p>
</li>
<li><p>让该类只拥有<code>private</code>的构造程序</p>
</li>
</ul>
</li>
<li><p>关于<code>final</code></p>
<p> 如果想要防止某个方法被覆盖，可以用<code>final</code>修饰该方法。将类标识成<code>final</code>的话意味着没有任何方法能够被覆盖。</p>
</li>
<li><p>覆盖的规则</p>
<ul>
<li>覆盖父类方法时，参数要一致，返回类型要兼容。</li>
<li>存取权限不能变小，只能相同或者更开放。</li>
</ul>
</li>
<li><p>方法的重载overload</p>
<p> 方法名相同，参数不同</p>
<ul>
<li>必须更改参数类型。</li>
<li>可以更改返回类型，但要符合返回类型是父类返回子类的要求。</li>
<li>重载的方法存取权限可以任意设定。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第三章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第三章-primitive主数据类型和引用"><a href="#第三章-primitive主数据类型和引用" class="headerlink" title="第三章  primitive主数据类型和引用"></a>第三章  primitive主数据类型和引用</h2><ol>
<li><p>变量有两种：<code>primitive主数据类型</code>、<code>引用</code></p>
<ul>
<li><p><code>primitive主数据类型</code><br>保存基本类型的值</p>
</li>
<li><p><code>引用</code><br>保存对象的引用</p>
<span id="more"></span></li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类型</th>
<th align="center">位数</th>
<th align="center">值域</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>boolean</code></td>
<td align="center">boolean</td>
<td align="center">JVM决定</td>
<td align="center">True或False</td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">char</td>
<td align="center">16bits</td>
<td align="center">0~65535</td>
</tr>
<tr>
<td align="center"><code>integer</code></td>
<td align="center">byte</td>
<td align="center">8bits</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">short</td>
<td align="center">16bits</td>
<td align="center">-2^15 ~ 2^15 -1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int</td>
<td align="center">32bits</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">long</td>
<td align="center">64bits</td>
<td align="center">-很大~+很大</td>
</tr>
<tr>
<td align="center"><code>浮点型</code></td>
<td align="center">float</td>
<td align="center">32bits</td>
<td align="center">范围规模可变</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">doubale</td>
<td align="center">64bits</td>
<td align="center">范围规模可变</td>
</tr>
</tbody></table>
<p> 小数默认为<code>double</code>,<code>float</code>标注为：float a = 3.14f;</p>
</li>
<li><p>primitive主数据类型赋值时要小心溢出</p>
</li>
<li><p>对象引用</p>
<ul>
<li>没有对象变量，只有<strong>引用到对象的变量</strong>。</li>
<li>对象引用变量保存的是存取变量的方法</li>
<li><strong>对象引用变量</strong>并不是对象的容器，而是<strong>类似指向对象的指针，或者是地址</strong>。在Java中不知道也不必知道引用变量中实际装载的是什么，只有JVM才会知道如何使用引用来取得该对象。</li>
</ul>
</li>
<li><p>对象声明、创建于赋值的3个步骤</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog myDog = <span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure>
<ol>
<li>声明一个引用变量 <code>Dog myDog</code>：要求JVM分配空间给引用变量，此引用变量永远是Dog类型。但是myDog可以引用不同的Dog，除非被<code>final</code>修饰，那样只能引用固定的Dog不会再变。也可以引用到空指针。</li>
<li>创建对象 <code>new Dog()</code>：要求JVM分配堆空间给新建的Dog对象。</li>
<li>连接对象和引用 <code>=</code></li>
</ol>
</li>
<li><p>int数组</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br></pre></td></tr></table></figure>
<p> 数组是对象，里面的元素是primitive主数据类型</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第八章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>1.<strong>抽象类</strong>：有些类不想要被初始化，也就是不想要被<code>new</code>出来，那么就标记这个类为<strong>抽象类</strong>，编译器就能知道这个类不能创建任何类型的实例。</p>
<span id="more"></span>

<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canine</span> <span class="keyword">extends</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">makeCanine</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Canine c;</span><br><span class="line">        c=<span class="keyword">new</span> Dog();  <span class="comment">// Yes! 赋值子类对象给父类引用</span></span><br><span class="line">        c=<span class="keyword">new</span> Canine();  <span class="comment">// No!!!抽象类！</span></span><br><span class="line">        c.roam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设计好继承结构之后，决定哪些类是抽象的，哪些是具体的，具体的类是可以被初始化为对象的。</p>
</li>
<li><p>抽象类不可以<code>new</code>一个对象，但是可以保存一个数组对象（给子类）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Animal[] animals = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>在使用多态时，要注意对象多种类型之间的差异。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line">Object dog3 = <span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure>
<p> 注意这三个dog对象的区别:</p>
<ul>
<li>dog1拥有  Dog / Animal / Object 中所有的⽅法。</li>
<li>dog2拥有Animal /<br>Object中的⽅法，不能调⽤Dog类特有的⽅法。</li>
<li>dog3只拥有 Object  中的⽅法，不能调⽤  Animal / Dog</li>
</ul>
<p> 类中的⽅法。这就是在使⽤多态过程中，需要特别注意的问题。</p>
</li>
<li><p>引用类型转换</p>
</li>
</ol>
<ul>
<li>大类型转小类型<br>上面例子里的dog2 and dog3是可以转换成dog类型的  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dog2 <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">    Dog dog4 = (dog) dog2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
先用<code>instanceof</code>判断</li>
<li>小类型转大类型<br>没有什么问题直接转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal dog5 = dog1;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p><code>Object</code>是所有对象的父类，<code>Object</code>不是抽象类</p>
<p> 一些方法，不加<code>final</code>的可以覆盖</p>
<ul>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
<li>getClass()</li>
</ul>
</li>
<li><p>Java不支持多重继承，可能会出现致命方块问题</p>
</li>
<li><p>接口</p>
<p> 部分类需要具体实现某些方法，如果定义在父类里作为抽象方法，那么不需要执行这个方法的子类也要具体实现这个抽象方法造成浪费，所以最好就是创造出类似于多重继承的关系，但是Java是不支持多重继承的，所以有接口这个概念。</p>
<ul>
<li><p>接口的应用场景：</p>
<ul>
<li>在当前类族中，需要实现某些子类不需要的方法</li>
<li>不同类族的多个类需要实现相同的方法</li>
</ul>
</li>
<li><p>接口是100%的纯抽象类，接口里的所有方法都是抽象的需要实现。</p>
</li>
<li><p>接口的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口里的方法必然是<code>public</code> and <code>abstract</code>,可以省略<code>abstract</code></p>
</li>
<li><p>不同继承树的类可以实现相同的接口，这也是接口应用场景之一</p>
</li>
<li><p>一个类可以使用多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>,<span class="title">Saveable</span>,<span class="title">paintable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第九章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h3><ol>
<li><p>堆与栈<br> JVM启动时会从底层操作系统取得一块内存并以此区段执行Java程序，一般关注两种内存区域：</p>
<ul>
<li>堆<code>heap</code>：对象的生存空间</li>
<li>栈<code>stack</code>:方法调用和局部变量的生存空间<span id="more"></span></li>
</ul>
<p> 区别1：</p>
<ul>
<li>实例变量：声明在类里，存在于对象所属的堆空间上</li>
<li>局部变量：局部变量和方法参数都声明在方法里，存在于栈上相对应的堆栈块中( in the frame corresponding to the method where the variables are declared.)，他们的生命周期只存在于方法存在栈上的那段时间</li>
</ul>
<p> <strong><big>区别2</big></strong>:</p>
<ul>
<li>对象本身：无论如何都存在于堆里</li>
<li>对象的引用：非<code>primitive</code>的变量只是保存对象的引用(<code>primitive</code>主数据类型变量也还是存放于栈)，存放在哪里还是看变量是哪里声明的。<ol>
<li>如果对象引用变量是声明在方法里的局部变量，该变量还是会存在于栈里。</li>
<li>如果对象引用变量是对象里的实例变量，那么存在于堆里。</li>
</ol>
</li>
</ul>
</li>
<li><p>调用一个方法时，该方法就会放到调用栈的栈顶，一直待到被执行完毕，如果方法内调用了别的方法，那么被调用的方法就会放到栈顶执行完毕后调用它的方法再回到栈顶。</p>
</li>
<li><p>对象在堆上所占空间：存放该对象所有实例变量的空间</p>
<ul>
<li>primitive主数据类型：根据类型分配空间</li>
<li>声明了一个对象引用变量但是没有赋值：只留下引用变量所用空间</li>
<li>声明了一个对象引用变量并赋值：引用变量所占空间+新建的对象所占空间</li>
</ul>
</li>
<li><p>构造函数：让你有机会介入<code>new</code>的过程。构造函数，没有显示的指定返回值类型，构造函数不会被继承。如果一个类，没有显示地编写构造器函数，Java 编译器会默认地为该类添加一个没有参数的构造器函数。反之， Java 编译器则不会再添加任何默认的构造函数。</p>
</li>
<li><p>构造器函数重载</p>
<p> 即一个类，有多个构造器函数，且它们的参数都不能相同，包括参数顺序不同、或者参数类型不同、或者参数个数不同。重载的构造器，代表了该类在创建对象时可以有多种不同的方式。</p>
</li>
<li><p>实例变量有默认值，0/0.0/false,引用默认为null</p>
</li>
<li><p>构造函数可以设为私有，代表该类以外不能存取，之后详细讨论</p>
</li>
<li><p>抽象类也有构造函数，虽然抽象类不能new，但是可以用于继承</p>
</li>
<li><p>构造函数链</p>
<p> <strong>构造函数执行的第一件事是去执行其父类构造函数</strong>，层层执行，连锁反应到执行Object的构造函数为止。</p>
<ul>
<li>如何调用父类构造函数    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">//Duck&#x27;s own methods</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没有调用<code>super()</code>的情况：编译器会自动加上<code>super()</code><ul>
<li>没有编写构造函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">className</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写了构造函数但是没有调用<code>super()</code><br>编译器会在每个重载版本的构造函数里加上<code>super()</code>,<strong>并且<code>super()</code>一定是构造函数的第一个语句</strong></li>
</ul>
编译器自动添加的一定是没有参数的版本，即使父类构造函数有重载，也一定调用的是无参数版本。</li>
</ul>
</li>
<li><p>构造器中使用<code>this()</code>调用重载的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意重载构造函数之间的调用关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String name,String gender)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重载的构造方法之间调用</span></span><br><span class="line">        <span class="keyword">this</span>(id,name,gender,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String name,String gender,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">&quot;, &quot;</span>+name+<span class="string">&quot;, &quot;</span>+gender+<span class="string">&quot;, &quot;</span>+age;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this()</code>用法</p>
<ul>
<li>构造方法之间调用，减少重复代码</li>
<li><code>this()</code>必须放在首行</li>
<li>一般是参数少的方法调用参数多的方法</li>
</ul>
</li>
<li><p>对象的生命周期</p>
<p>对象的生命周期取决于引用它的引用变量，当它的引用变量消失后对象就变成可回收得了。</p>
<p>实例变量存活在对象中，生命周期与对象一致。</p>
</li>
<li><p><code>life</code>和<code>scope</code>的区别</p>
</li>
</ol>
<ul>
<li>life：局部变量存活到方法执行完毕</li>
<li>scope：作用域，局部变量的范围只局限于声明它的方法之内，当该方法调用别的方法时，局部变量虽然或者但是不在当前范围内</li>
</ul>
<ol start="13">
<li>释放对象引用的三种情况<ul>
<li>引用永久性地离开它的范围，比如方法内声明赋值的对象引用</li>
<li>引用被赋值到其它对象上，一开始引用的对象最后就会被回收</li>
<li>直接将引用设为null</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python零碎知识点记录01</title>
    <url>/2021/03/05/Python%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B901/</url>
    <content><![CDATA[<p>这个记录并不成体系，只是随手记录的知识点做个归档，积攒一部分后就继续补充  </p>
<ol>
<li><p>取整</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3.14</span></span><br><span class="line"><span class="built_in">int</span>(a)  <span class="comment"># 向下取整 3</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.ceil(a)  <span class="comment"># 向上取整 4</span></span><br><span class="line"><span class="built_in">round</span>(a)  <span class="comment"># 四舍五入</span></span><br><span class="line">math.modf(a) <span class="comment"># (0.14,3.0) 分别取小数和整数部分，返回元组</span></span><br><span class="line">math.modf(<span class="number">4.2</span>)  </span><br><span class="line"><span class="comment"># (0.20000000000000018, 4.0)</span></span><br><span class="line"><span class="comment"># 按理说应该返回 (0.2, 4.0) 才对。这里涉及到了另一个问题，即浮点数在计算机中的表示，在计算机中是无法精确的表示小数的，至少目前的计算机做不到这一点。上例中最后的输出结果只是 0.2 在计算中的近似表示。Python 和 C 一样, 采用 IEEE 754 规范来存储浮点数。</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>多个list创建dataframe</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msc = pd.DataFrame(fileNames, columns = [<span class="string">&#x27;filename&#x27;</span>])</span><br><span class="line">msc[<span class="string">&#x27;title&#x27;</span>] = mtitle</span><br><span class="line">msc[<span class="string">&#x27;artist&#x27;</span>] = martist</span><br><span class="line">msc[<span class="string">&#x27;size&#x27;</span>] = msize</span><br><span class="line">msc[<span class="string">&#x27;format&#x27;</span>] = mformat</span><br></pre></td></tr></table></figure></li>
<li><p>dataframe打印不完整的问题</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有列</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 显示所有行</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 设置value的显示长度为100，默认为50</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;max_colwidth&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>字符串大小写转换和检测</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&#x27;www.bing.com&#x27;</span></span><br><span class="line">str2=<span class="string">&#x27;i love mcs&#x27;</span></span><br><span class="line">str1.title()  <span class="comment"># Www.Bing.Com</span></span><br><span class="line">str2.title()  <span class="comment"># I Love Mcs</span></span><br><span class="line"><span class="comment"># title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。</span></span><br><span class="line">str1.lower()  <span class="comment"># lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。</span></span><br><span class="line">str1.upper()  <span class="comment"># upper()方法将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。</span></span><br><span class="line">str1[<span class="number">0</span>].isupper()  <span class="comment">#false 是否大写</span></span><br><span class="line">str1[<span class="number">0</span>].islower()  <span class="comment">#true是否小写</span></span><br></pre></td></tr></table></figure>

<p> 参考：<a href="https://www.jianshu.com/p/79e7b17cd831">https://www.jianshu.com/p/79e7b17cd831</a></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCapitalUse</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        </span><br><span class="line">        is_upper = [c.isupper() <span class="keyword">for</span> c <span class="keyword">in</span> word]   <span class="comment"># 大写字符判别列表</span></span><br><span class="line">        is_lower = [c.islower() <span class="keyword">for</span> c <span class="keyword">in</span> word]   <span class="comment"># 小写字符判别列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(is_upper) <span class="keyword">or</span> <span class="built_in">all</span>(is_lower):              </span><br><span class="line">        <span class="comment"># 如果所有字符都是大写或小写</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>                         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(is_upper):                               <span class="comment"># 如果既有大写又有小写</span></span><br><span class="line">            <span class="keyword">return</span> is_upper[<span class="number">0</span>] <span class="keyword">and</span> <span class="built_in">all</span>(is_lower[<span class="number">1</span>:])    <span class="comment"># 要求第一个大写其他都小写</span></span><br></pre></td></tr></table></figure>
<p> 使用<code>any()</code>函数判断列表中是否有一个元素的布尔值为<code>True</code>，使用<code>all()</code>函数判断列表中是否所有元素的布尔值均为<code>True</code>。</p>
</li>
<li><p>dataframe导出excel</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&#x27;output.xlsx&#x27;</span>)</span><br><span class="line">info_marks.to_excel(writer)</span><br><span class="line">writer.save()</span><br><span class="line">print(<span class="string">&#x27;DataFrame is written successfully to the Excel File.&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>dataframe索引</p>
</li>
<li><p>判断nonetype<br><code>is None</code></p>
</li>
<li><p>lambda函数</p>
</li>
<li><p>dataframe大小</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(df) 	<span class="comment"># 获取行数</span></span><br><span class="line"><span class="built_in">len</span>(df.columns) 	<span class="comment"># 获取列数</span></span><br><span class="line">df.shape 	<span class="comment"># 获取行数和列数</span></span><br><span class="line">df.size 	<span class="comment"># 得到元素个数</span></span><br></pre></td></tr></table></figure></li>
<li><p>dataframe删除列<br>df.drop()</p>
</li>
<li><p>split()和rsplit()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用split：</span></span><br><span class="line">path = <span class="string">&#x27;www.chengxuan.com/subactivity/1033/page/1&#x27;</span> </span><br><span class="line">path.split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">[<span class="string">&quot;www.chengxuan.com&quot;</span>, <span class="string">&quot;subactivity&quot;</span>, <span class="number">1033</span>, <span class="string">&quot;page&quot;</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用rsplit：</span></span><br><span class="line">path.rsplit(<span class="string">&quot;/&quot;</span>,<span class="number">1</span>)</span><br><span class="line">[<span class="string">&quot;www.chengxuan.com/subactivity/1033/page&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>rsplit(“/“,1) 中的1，表示从字符串右端分割1次，2就是分割2次。</p>
</li>
<li><p>python 删除字符串中以\x开头的特殊字符</p>
</li>
<li><p>python判断字符是否是中文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_Chinese</span>(<span class="params">word</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\u4e00&#x27;</span> &lt;= ch &lt;= <span class="string">&#x27;\u9fff&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">print(is_Chinese(<span class="string">&quot;中文&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>使用split匹配多个分隔符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&#x27;ab/cd.123&#x27;</span></span><br><span class="line">print(line.split(<span class="string">&#x27;/&#x27;</span>))  <span class="comment"># [&#x27;ab&#x27;,&#x27;cd.123&#x27;]</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(re.split(<span class="string">&#x27;[/\.]&#x27;</span>,line))  <span class="comment"># [&#x27;ab&#x27;, &#x27;cd&#x27;, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断字符串是否全部是中文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验是否全是中文字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_all_chinese</span>(<span class="params">strs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _char <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;\u4e00&#x27;</span> &lt;= _char &lt;= <span class="string">&#x27;\u9fa5&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串截取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">print(<span class="string">&quot;str[0:3]：&quot;</span>+<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># 正向截取字符串 0~3（不包含3）   即 012</span></span><br><span class="line">print(<span class="string">&quot;str[:]:&quot;</span>+<span class="built_in">str</span>[:])  <span class="comment"># 正向输出所有字符串    即0123456789</span></span><br><span class="line">print(<span class="string">&quot;str[6:]：&quot;</span>+<span class="built_in">str</span>[<span class="number">6</span>:]) <span class="comment"># 正向输出字符串 从 5 （不含5）~  结束  即 6789</span></span><br><span class="line">print(<span class="string">&quot;str[:-3]：&quot;</span>+<span class="built_in">str</span>[:-<span class="number">3</span>]) <span class="comment"># 正向输出  从开始 ~ 倒数第第3个字符（不含第3个）即 0123456</span></span><br><span class="line">print(<span class="string">&quot;str[2]：&quot;</span>+<span class="built_in">str</span>[<span class="number">2</span>]) <span class="comment">#输出第3个字符 即 2</span></span><br><span class="line">print(<span class="string">&quot;str[:-1]：&quot;</span>+<span class="built_in">str</span>[:-<span class="number">1</span>]) <span class="comment"># 正向输出  从开始 ~ 倒数第第1个字符（不含第1个）即 012345678</span></span><br><span class="line">print(<span class="string">&quot;str[-1]：&quot;</span>+<span class="built_in">str</span>[-<span class="number">1</span>]) <span class="comment"># 输出最后一个字符 即 9</span></span><br><span class="line">print(<span class="string">&quot;str[-3:-1]:&quot;</span>+<span class="built_in">str</span>[-<span class="number">3</span>:-<span class="number">1</span>]) <span class="comment">#逆序输出  从倒数第 3 ~ 倒数第 1 （不含） 即 78</span></span><br><span class="line">print(<span class="string">&quot;str[-3:]:&quot;</span>+<span class="built_in">str</span>[-<span class="number">3</span>:]) <span class="comment"># 逆序输出 从倒数第 3 ~ 最后 即 789</span></span><br><span class="line">print(<span class="string">&quot;str[::-1]：&quot;</span>+<span class="built_in">str</span>[::-<span class="number">1</span>]) <span class="comment"># 逆序输出,连续输出所有字符串  即  9876543210</span></span><br><span class="line">print(<span class="string">&quot;str[::-2]：&quot;</span>+<span class="built_in">str</span>[::-<span class="number">2</span>]) <span class="comment"># 逆序输出，从最后一个开始，每隔2个字符串输出一个  97531</span></span><br><span class="line">print(<span class="string">&quot;str[::1]：&quot;</span>+<span class="built_in">str</span>[::<span class="number">1</span>]) <span class="comment"># 正序输出， 连续输出所有字符串  即  0123456789</span></span><br><span class="line">print(<span class="string">&quot;str[::2]：&quot;</span>+<span class="built_in">str</span>[::<span class="number">2</span>]) <span class="comment"># 正序输出，从第一个开始，每隔2个字符串输出一个即 02468</span></span><br><span class="line">print(<span class="string">&quot;str[:-2:4]:&quot;</span>+<span class="built_in">str</span>[:-<span class="number">2</span>:<span class="number">4</span>])<span class="comment"># 正序输出 从第一个开始，每隔4个字符输出一个 即 04</span></span><br><span class="line">print(<span class="string">&quot;str[1:-2:4]:&quot;</span>+<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">2</span>:<span class="number">4</span>])<span class="comment"># 正序输出 从第二个开始，每隔4个字符输出一个 即 15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>粗略总结：str[(idx1):(idx2)(:step)]<br>idx1:起始index,包含进去<br>idx2:截止index,不包含<br>step:步长，负数的话就是反向输出</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第四章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="方法操作实例变量"><a href="#方法操作实例变量" class="headerlink" title="方法操作实例变量"></a>方法操作实例变量</h3><ol>
<li><p>如果方法被声明为有返回类型，那么必须返回所声明的类型</p>
</li>
<li><p>Java通过拷贝传递值</p>
</li>
<li><p>封装</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String brand;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String abrand)</span></span>&#123;</span><br><span class="line">    brand = abrand;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">getBrand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> brand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>封装的基本原则</strong>：将实例变量标记为<code>private</code>,将<code>getters</code>、<code>setters</code>标记为<code>public</code>。</p>
<span id="more"></span></li>
<li><p>可以手动初始化实例变量，如果没有手动初始化的话也是默认有值的。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">integers(包括char)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">floating points</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">booleans</td>
<td align="center">False</td>
</tr>
<tr>
<td align="center">references</td>
<td align="center">null</td>
</tr>
</tbody></table>
</li>
<li><p>实例变量与局部变量之间的差别</p>
<ul>
<li>实例变量声明在类内而非方法中</li>
<li>局部变量声明在方法内</li>
<li>局部变量在使用前必须初始化</li>
</ul>
</li>
<li><p>变量的比较</p>
<ul>
<li>使用<code>==</code>比较两个primitive主数据类型是否相等，或者判断两个引用是否引用同一个对象  <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line">System.out.println(a == b);  # true</span><br><span class="line"># 只是比较字节组合，无关类型</span><br></pre></td></tr></table></figure></li>
<li>使用<code>equals()</code>判断两个对象在意义上是否相等，例如两个String对象是否有相同字节</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第六章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="使用Java函数库"><a href="#使用Java函数库" class="headerlink" title="使用Java函数库"></a>使用Java函数库</h3><ol>
<li>ArrayList初识<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ArrayList&lt;Egg&gt; myList = <span class="keyword">new</span> ArrayList&lt;Egg&gt;();</span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">Egg s = <span class="keyword">new</span> Egg();</span><br><span class="line">Egg b = <span class="keyword">new</span> Egg();</span><br><span class="line">myList.add(s);</span><br><span class="line">myList.add(b);</span><br><span class="line"><span class="comment">// 另一种增加元素写法</span></span><br><span class="line">ArrayList&lt;Integer&gt; lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;</span><br><span class="line">          &#123;</span><br><span class="line">              add(<span class="number">1</span>);</span><br><span class="line">              add(<span class="number">2</span>);</span><br><span class="line">              add(<span class="number">3</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="comment">// 查询大小</span></span><br><span class="line"><span class="keyword">int</span> theSize = myList.size();</span><br><span class="line"><span class="comment">// 查询特定元素</span></span><br><span class="line"><span class="keyword">boolean</span> isIn = myList.contains(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询特定元素位置,返回-1代表没有</span></span><br><span class="line"><span class="keyword">int</span> idx = myList.indexOf(b);</span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="keyword">boolean</span> isEpt = myList.isEmpty();</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">myList.remove(s);  <span class="comment">//删除成功的话返回true</span></span><br><span class="line">myList.remove(<span class="number">0</span>);  <span class="comment">//返回删除的元素</span></span><br><span class="line"><span class="comment">//可以是索引可以是对象，如果元素类型是int删除元素的话需要把int转为Object</span></span><br><span class="line">integers.remove(Integer.valueOf(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>遍历ArrayList的四种方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  ArrayList&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  aList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  aList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  aList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法1</span></span><br><span class="line">  Iterator it1 = aList.iterator();</span><br><span class="line">  <span class="keyword">while</span>(it1.hasNext())&#123;</span><br><span class="line">    System.out.println(it1.next());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法2</span></span><br><span class="line">  <span class="keyword">for</span> (Iterator it2 = aList.iterator();it2.hasNext();)&#123;</span><br><span class="line">    System.out.println(it2.next());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法3</span></span><br><span class="line">  <span class="keyword">for</span>(String tmp:aList )&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//方法4</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size(); i ++)&#123;</span><br><span class="line">        System.out.println(aList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>读取字符输入流</li>
</ol>
<ul>
<li><code>Reader</code>是字符输入流的抽象基类<ul>
<li><code>Read()</code>读取单个字符返回<code>int</code>,需要转成<code>char</code>，到达流的末尾时返回-1。</li>
<li><code>read(char[] cbuf)</code></li>
<li><code>close()</code></li>
</ul>
</li>
<li><code>InputStreamReader</code>是字节流与字符流之间的桥梁，能将字节流输出为字符流，并且能为字节流指定字符集，可输出一个个的字符</li>
<li><code>FileReader</code>把<code>FileInputStream</code>中的字节流根据字符编码方式转成字符流。</li>
<li><code>BufferedReader</code>可以把字符输入流进行封装，将数据进行缓冲，提高读取效率。<ul>
<li><code>readLine</code>读取一个文本行， 从字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取。到达流末尾返回null</li>
</ul>
</li>
</ul>
<p>  <strong>读取控制台输入字符</strong><br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader is = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><strong>短运算符</strong></li>
</ol>
<ul>
<li><p><code>&amp;&amp;</code>与</p>
</li>
<li><p><code>||</code></p>
</li>
<li><p><code>!=</code></p>
</li>
<li><p><code>!</code></p>
<p><strong>长运算符</strong></p>
</li>
<li><p><code>&amp;</code></p>
</li>
<li><p><code>|</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java 第五章学习笔记</title>
    <url>/2021/03/05/Head%20First%20Java%20%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><ol>
<li>编写类的建议流程</li>
</ol>
<ul>
<li>确定类的功能</li>
<li>列出实例变量和方法</li>
<li>编写方法的伪码</li>
<li>编写方法的测试用程序</li>
<li>实现类</li>
<li>测试方法</li>
<li>出错/重新设计</li>
</ul>
<ol start="2">
<li>加强版<code>for</code>循环</li>
</ol>
<ul>
<li><p><code>for each</code>循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String name:nameArray)&#123;&#125;</span><br><span class="line"><span class="comment">// String不是固定的，是根据后面数组元素类型写的</span></span><br><span class="line"><span class="comment">// name自己定</span></span><br></pre></td></tr></table></figure>
<p>类似于python里的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[]:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>java还支持两个变量控制<code>for</code>循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">4</span>;a &lt; b;a++,b--)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>还有就是三个部分是可以缺省的，初始化可以放在循环体外部，增量表达可以放在循环体内部，条件表达式不推荐缺省。</p>
</li>
</ul>
<ol start="3">
<li><p>转换primitive主数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> variable_int = Integar.parseInt(variable_str);</span><br></pre></td></tr></table></figure></li>
<li><p><code>i++</code>vs<code>++i</code></p>
<p> <code>i++</code>:先运用变量的值再执行加减操作</p>
<p> <code>++i</code>:先执行加减操作再运用变量的值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java零碎知识点记录01</title>
    <url>/2021/03/05/Java%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<p>不成体系的知识点记录</p>
<ol>
<li><p>一个.java文件里可以有多个class嘛？<br> 一个.java里面可以有几个class，但是只能有一个public class，且public class的名称必须与.java同名。</p>
<span id="more"></span></li>
<li><p>源文件javac出多个class文件出来!是怎么回事？</p>
<ul>
<li><p>1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里每个class都是一个.class文件</p>
</li>
<li><p>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生两个 class 文件，一个 <code>A.class</code>,一个<code> A$B.class</code></p>
</li>
<li><p>3 使用匿名类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        button.addActionLisener(<span class="keyword">new</span> ActionListener() &#123;...&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也会产生多个 class，一个 A.class，一个 A$1.class</p>
</li>
</ul>
<p> <a href="https://blog.csdn.net/u012860938/article/details/38896229?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">参考文献</a></p>
</li>
<li><p>如何获取Java类中的变量名的字串<br><a href="https://blog.csdn.net/akalius/article/details/83207189?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">参考</a></p>
</li>
<li><p>Java字符串可以引用传递吗？<br>结论：Java 字符串不是引用传递而是值传递；更进一步的说，Java 只有值传递，没有引用传递。<br><a href="https://article.itxueyuan.com/Da6vE0">参考</a></p>
</li>
<li><p>Java注释</p>
</li>
</ol>
<ul>
<li><p>单行注释 <code>//</code></p>
<p>  快捷键：<code>Ctrl + /</code></p>
</li>
<li><p>多行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注释</span></span><br><span class="line"><span class="comment">*注释2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>  快捷键：<code>Ctrl+Shift+/</code></p>
</li>
<li><p>文档注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>输入<code>/**</code>后<code>Enter</code></p>
</li>
</ul>
<ol start="6">
<li>HashMap有点像python里的字典，是<code>key:value</code>的映射，<code>key</code>和<code>value</code>的类型可以不相同，HashMap是无序的。</li>
</ol>
<ul>
<li>新增<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">//声明并添加</span></span><br><span class="line"><span class="comment">//Java9之后才能支持</span></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">HashMap&lt;Integer,String&gt; map = Map.of(<span class="number">1</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>,<span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="comment">// 加入元素</span></span><br><span class="line">HashMap&lt;Integer,String&gt; Sites = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>查<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据key查找value</span></span><br><span class="line">System.out.println(Sites.get(<span class="number">3</span>)); <span class="comment">// Taobao</span></span><br><span class="line"><span class="comment">//查找是否包含所要查询的key or value，返回true/false</span></span><br><span class="line">System.out.println(Sites.containsKey(<span class="number">2</span>));  <span class="comment">//true</span></span><br><span class="line">System.out.println(Sites.containsValue(<span class="string">&quot;a&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li>删<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除单个元素</span></span><br><span class="line">Sites.remove(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 删除所有</span></span><br><span class="line">Sites.clear();</span><br></pre></td></tr></table></figure></li>
<li>迭代<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据keySet()</span></span><br><span class="line"><span class="keyword">for</span>(Integer ikey:Sites.keySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key:&quot;</span>+ikey+<span class="string">&quot;value:&quot;</span>+Sites.get(ikey))；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String val:Sites.values())&#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li><p><code>toLowerCase() </code>转换为小写字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.toLowerCase();</span><br></pre></td></tr></table></figure></li>
<li><p><code>print</code>vs<code>println</code>vs<code>printf</code></p>
</li>
</ol>
<ul>
<li><p>println(“test”)相当于print(“test\n”)</p>
</li>
<li><p><code>printf</code>是格式化输出的形式，可以用于一行输出多个变量。</p>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">代表的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%c</td>
<td align="center">单个字符</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">十进制整数</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">十进制浮点</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">%u</td>
<td align="center">无符号的十进制数</td>
</tr>
<tr>
<td align="center">%o</td>
<td align="center">八进制数</td>
</tr>
<tr>
<td align="center">%x</td>
<td align="center">十六进制数</td>
</tr>
<tr>
<td align="center">%%</td>
<td align="center">输出百分号</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%d,%d&quot;</span>,a,b);    <span class="comment">//通过占位符，打印多个变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="9">
<li><p><code>hashCode()</code>和<code>equal()</code>的区别与联系</p>
<p> <a href="https://blog.csdn.net/fenglibing/article/details/8905007">hashCode()详解</a></p>
<ul>
<li><code>hashCode</code>是用来在散列存储结构中确定对象的存储地址</li>
<li>如果两个对象相同，就是适用于<code>equals(java.lang.Object)</code> 方法，那么这两个对象的<code>hashCode</code>一定要相同；</li>
<li>如果对象的<code>equals</code>方法被重写，那么对象的<code>hashCode</code>也尽量重写，并且产生<code>hashCode</code>使用的对象，一定要和<code>equals</code>方法中使用的一致，否则就会违反上面提到的第2点；</li>
<li>两个对象的<code>hashCode</code>相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们<strong>存放在同一个篮子里</strong>。</li>
</ul>
<p> 回顾：<code>==</code>与<code>equals()</code></p>
</li>
<li><p><code>HashSet</code>相关</p>
<p>set里元素无序不允许重复</p>
<ul>
<li><code>HashSet</code>底层数据结构是哈希表</li>
<li><code>HashSet</code>如何保证元素唯一性<br>  通过<code>hashCode()</code>、<code>equals()</code>两个方法判断<ul>
<li>元素hashcode相同，则判断equals()是否为true</li>
<li>元素hashcode不同，则不用调用equals()</li>
</ul>
</li>
</ul>
<p>上个item里重写了<code>hashCode()</code>和<code>equals()</code>方法后，两个实例并不相同但是改写后是两个true所以<code>HashSet</code>认为是同一个元素，当然这也就失去了意义。</p>
</li>
<li><p><code>instanceof()</code></p>
<p><code>instanceof</code>是Java中的二元运算符，左边是<strong>对象</strong>，右边是<strong>类</strong>；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</p>
</li>
<li><p><a href="https://www.jianshu.com/p/95f349258afb">泛型和泛型通配符</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>3.1415926535</title>
    <url>/2021/03/14/3-1415926535/</url>
    <content><![CDATA[<p>今天是3月14日<br>这是$\pi$小数点后314位  </p>
<span id="more"></span>
<p>π = 3.14159 26535 89793 23846 26433 83279 50288 41971 69399 37510 58209 74944 59230 78164 06286 20899 86280 34825 34211 70679 82148 08651 32823 06647 09384 46095 50582 23172 53594 08128 48111 74502 84102 70193 85211 05559 64462 29489 54930 38196 44288 10975 66593 34461 28475 64823 37867 83165 27120 19091 45648 56692 34603 48610 45432 66482 13393 60726 02491 41273 72458 70066 0631</p>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
  </entry>
  <entry>
    <title>Head First Java 第十章学习笔记</title>
    <url>/2021/03/10/Head%20First%20Java%20%E7%AC%AC%E5%8D%81%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="数字与静态"><a href="#数字与静态" class="headerlink" title="数字与静态"></a>数字与静态</h3><p>这一章的东西着实让人头大，像毛线球。</p>
<h4 id="静态方法：一种不依靠实例变量也就不需要对象的行为，由static标记。"><a href="#静态方法：一种不依靠实例变量也就不需要对象的行为，由static标记。" class="headerlink" title="静态方法：一种不依靠实例变量也就不需要对象的行为，由static标记。"></a>静态方法：一种不依靠实例变量也就不需要对象的行为，由<code>static</code>标记。</h4><span id="more"></span>
<p>静态方法与实例方法的不同</p>
<ul>
<li> 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调⽤静态方法可以无需创建对象。</li>
<li><strong>静态方法<code>访问本类成员时</code>，只允许访问静态成员（ <code>静态成员变量</code>和<code>静态方法</code>）</strong>，无法访问实例成员变量和实例方法。<h5 id="其实有一种合法地在静态方法里访问类内非静态成员的方法，就是在静态方法里创建所属类的对象，通过这个对象访问类内非静态成员"><a href="#其实有一种合法地在静态方法里访问类内非静态成员的方法，就是在静态方法里创建所属类的对象，通过这个对象访问类内非静态成员" class="headerlink" title="其实有一种合法地在静态方法里访问类内非静态成员的方法，就是在静态方法里创建所属类的对象，通过这个对象访问类内非静态成员"></a>其实有一种合法地在静态方法里访问类内非静态成员的方法，就是在静态方法里创建所属类的对象，通过这个对象访问类内非静态成员</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticMethodTest</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         staticMethodTest smt = <span class="keyword">new</span> staticMethodTest(); </span><br><span class="line">         <span class="comment">// 创建所属类的对象</span></span><br><span class="line">         System.out.printf(<span class="string">&quot;%d,%d,%d,%d&quot;</span>, a, b, smt.getc(), smt.getd()); </span><br><span class="line">         <span class="comment">// 通过所属类的对象访问类内非静态成员</span></span><br><span class="line">         smt.nonStatic();</span><br><span class="line">         <span class="comment">//System.out.println(c);无法直接访问非静态变量c</span></span><br><span class="line">         anotherInnerCls innerCls = <span class="keyword">new</span> anotherInnerCls();</span><br><span class="line">         anotherInnerCls innerCls1 = <span class="keyword">new</span> anotherInnerCls();</span><br><span class="line">         System.out.println(innerCls.a);</span><br><span class="line">         <span class="comment">//System.out.println(innerCls.b);  b是private无法访问</span></span><br><span class="line">         innerCls.cplus();</span><br><span class="line">         innerCls1.cplus();</span><br><span class="line">         System.out.println(anotherInnerCls.c);</span><br><span class="line">         <span class="comment">//访问外部类的静态成员</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> d;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;  nonStatic method&quot;</span>);</span><br><span class="line">         <span class="comment">//main(new String[2]);这里是可以编译通过的</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">anotherInnerCls</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">22</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cplus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         c++;</span><br><span class="line">         System.out.println(<span class="string">&quot;c+1&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1,2,3,4  nonStatic method</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// c+1</span></span><br><span class="line"><span class="comment">// c+1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h5 id="总结一下，静态方法只能访问静态成员，如果想要访问非静态成员，需要建立该成员所属类的对象，通过对象访问。我也母鸡这样说对不对，反正逻辑上是对的。"><a href="#总结一下，静态方法只能访问静态成员，如果想要访问非静态成员，需要建立该成员所属类的对象，通过对象访问。我也母鸡这样说对不对，反正逻辑上是对的。" class="headerlink" title="总结一下，静态方法只能访问静态成员，如果想要访问非静态成员，需要建立该成员所属类的对象，通过对象访问。我也母鸡这样说对不对，反正逻辑上是对的。"></a>总结一下，静态方法只能访问静态成员，如果想要访问非静态成员，需要建立该成员所属类的对象，通过对象访问。我也母鸡这样说对不对，反正逻辑上是对的。</h5></li>
</ul>
<p>限制类被实例化</p>
<ul>
<li>标记这个类为抽象类</li>
<li>将这个类的构造函数设为私有。如果一个类的所有方法都是静态的，那么这个类不希望被实例化，可以将构造函数标记为<code>private</code>。</li>
</ul>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>被同类所有实例共享的变量</p>
<ul>
<li>静态变量会在该类任何对象创造之前初始化</li>
<li>静态变量会在该类任何静态方法执行之前初始化</li>
</ul>
<h4 id="静态final常数"><a href="#静态final常数" class="headerlink" title="静态final常数"></a>静态<code>final</code>常数</h4><p>标记为<code>final</code>的变量在初始化之后就不再改变，所以静态<code>final</code>在类被加载后维持原值作为常数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>
<p>命名惯例规定常数变量的名称全部大写<br>常数必须初始化，要么通过赋值语句要么通过静态初始化器。</p>
<h4 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h4><ul>
<li><p><code>静态初始化器</code>，也叫<code>类初始化器</code>，是由<code>static</code>修饰的一对花括号<code>&#123;&#125;</code>括起来的语句组。作用是对整个类完成初始化操作，包括给<code>static</code>成员变量赋初值，它在所属类被加载入内存时由系统调用执行。</p>
</li>
<li><p><code>实例初始化器</code>用于实例初始化，格式是没有修饰的一对花括号<code>&#123;&#125;</code>，会在构造函数执行前执行。<br>Tip：如果类的全部构造函数中存在共同的处理（创建实例时一定要执行的处理）,那么该共同的处理就可以独立为实例初始化器。</p>
<p><a href="https://blog.csdn.net/jianghao233/article/details/101148478">参考</a></p>
</li>
</ul>
<h4 id="总结final"><a href="#总结final" class="headerlink" title="总结final"></a>总结<code>final</code></h4><ul>
<li><code>final</code>的变量代表不能改变它的值。<br><code>final</code>实例变量初始化的方式<ul>
<li>声明时赋值</li>
<li>实例初始化器</li>
<li>构造函数</li>
</ul>
</li>
<li><code>final</code>的方法代表不能被覆盖</li>
<li><code>final</code>的类代表不能被继承</li>
</ul>
<h4 id="Math的方法"><a href="#Math的方法" class="headerlink" title="Math的方法"></a>Math的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Math.random()返回[0.0,1.0)区间的double</span></span><br><span class="line"><span class="keyword">double</span> r1 = Math.random();</span><br><span class="line"><span class="keyword">int</span> r2 = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Math.abs()返回double类型绝对值，但是这个方法有overload,如果输入int返回int,输入double返回double</span></span><br><span class="line"><span class="keyword">int</span> a1 = Math.abs(-<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Math.round()返回最接近输入的整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testRoundRuturn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = -<span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">float</span> f = -<span class="number">1.5f</span>;</span><br><span class="line">        System.out.println(getType(Math.round(d)) + <span class="string">&quot;\t&quot;</span> + Math.round(d));</span><br><span class="line">        System.out.println(getType(Math.round(f)) + <span class="string">&quot;\t&quot;</span> + Math.round(f));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span> </span>&#123; <span class="comment">//获取变量类型方法</span></span><br><span class="line">        <span class="keyword">return</span> o.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class java.lang.Long	0</span></span><br><span class="line"><span class="comment">//class java.lang.Integer	-1</span></span><br><span class="line"><span class="comment">//输入double返回long，输入float返回int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取整除了round之外还有Math.ceil()和Math.floor()</span></span><br><span class="line"><span class="comment">//Math.ceil()向上取整，输入double/float，返回double</span></span><br><span class="line"><span class="comment">//Math.floor()向下取整，输入double/float，返回double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Math.min()和Math.max()比较两个输入大小，返回类型与输入相同，返回类型根据输入来定，两个输入类型可以不一样，输出一定要是大一点的类型。</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> a2 = <span class="number">2.1f</span>;</span><br><span class="line">System.out.println(getType(Math.max(a1,a2)));</span><br><span class="line"><span class="comment">//class java.lang.Float</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Wrapper-Classes"><a href="#Wrapper-Classes" class="headerlink" title="Wrapper Classes"></a>Wrapper Classes</h4><p>虽然Java是面向对象语言，但是它在设计之初却保留了一些面向过程语言的特性，Java5.0之前它的8个primitive数据类型就是非面向对象的——没有属性、没有方法，它们不是类。<br>有时需要像对象一样处理primitive数据类型，所以为每个数据类型设计了对应的包装类<code>wrapper class</code>，名称就是各类型全称首字母大写。<br>使用包装类有以下作用：</p>
<ul>
<li>提供了一些实用方法，比如：基本类型之间相互转换</li>
<li>要求Object类型时无法使用基本数据类型，比如collection内不允许存放基本数据类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wrap</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">Integer iwrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">//unwrap</span></span><br><span class="line"><span class="keyword">int</span> iUnwrapped = iwap.intValue();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拓展：int-class-VS-Integer-class"><a href="#拓展：int-class-VS-Integer-class" class="headerlink" title="拓展：int.class VS Integer.class"></a>拓展：<code>int.class</code> VS <code>Integer.class</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; a = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;Integer&gt; b = Integer.TYPE;</span><br><span class="line">Class&lt;Integer&gt; c = Integer.class;</span><br><span class="line"></span><br><span class="line">System.out.println(System.identityHashCode(a));</span><br><span class="line">System.out.println(System.identityHashCode(b));</span><br><span class="line">System.out.println(System.identityHashCode(c));</span><br><span class="line"><span class="comment">// 366712642</span></span><br><span class="line"><span class="comment">// 366712642</span></span><br><span class="line"><span class="comment">// 1829164700</span></span><br></pre></td></tr></table></figure>

<h4 id="Autoboxing"><a href="#Autoboxing" class="headerlink" title="Autoboxing"></a><code>Autoboxing</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ArrayList&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">   <span class="comment">//without autoboxing</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">   Integer itg_a = <span class="keyword">new</span> Integer(a);</span><br><span class="line">   integerArrayList.add(itg_a);</span><br><span class="line">   Integer itg_al0 = (Integer) integerArrayList.get(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> a_back = itg_al0.intValue();</span><br><span class="line">   System.out.println(a_back);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//autoboxing</span></span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">   integerArrayList.add(b);</span><br><span class="line">   <span class="keyword">int</span> b_back = integerArrayList.get(<span class="number">1</span>);</span><br><span class="line">   System.out.println(b_back);</span><br><span class="line">   System.out.println(getType(integerArrayList.get(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之用法很多，返回类型、方法参数、布尔表达式都可以自动转换。</p>
<h4 id="为什么不直接声明ArrayList-lt-int-gt"><a href="#为什么不直接声明ArrayList-lt-int-gt" class="headerlink" title="为什么不直接声明ArrayList&lt;int&gt;"></a>为什么不直接声明<code>ArrayList&lt;int&gt;</code></h4><p>generic类型的规则规定只能指定类或者接口类型，<code>ArrayList&lt;int&gt;</code>会无法通过编译</p>
<h4 id="String与primitive主数据类型的相互转换"><a href="#String与primitive主数据类型的相互转换" class="headerlink" title="String与primitive主数据类型的相互转换"></a><code>String</code>与primitive主数据类型的相互转换</h4><ul>
<li><code>String</code>转<code>primitive</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> s2i = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">double</span> s2d = Double.parseDouble(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line"><span class="comment">// 没有parseBoolean()</span></span><br><span class="line"><span class="keyword">boolean</span> s2b = <span class="keyword">new</span> Boolean(<span class="string">&quot;true&quot;</span>).booleanValue();</span><br></pre></td></tr></table></figure></li>
<li><code>primitive</code>类型转<code>String</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">String d2s1 = <span class="string">&quot;&quot;</span> + d;</span><br><span class="line">String d2s2 = Double.toString(d);</span><br></pre></td></tr></table></figure>
<code>+</code>是Java里唯一有重载的运算符</li>
</ul>
<h4 id="数字的格式化输出"><a href="#数字的格式化输出" class="headerlink" title="数字的格式化输出"></a>数字的格式化输出</h4><p><code>String.format()</code><br>格式化说明：<br><code>%[argument number][flags][width][precision]type</code>  </p>
<h4 id="时间日期格式化"><a href="#时间日期格式化" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h4><ul>
<li>完整的日期时间<br><code>String.format(&quot;%tc&quot;,new Date())</code></li>
<li>只有时间<br><code>String.format(&quot;%tr&quot;,new Date())</code></li>
<li>周、月、日，需要自己组合 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date today = <span class="keyword">new</span> Date();</span><br><span class="line">String s = String.format(<span class="string">&quot;%tA, %tB %td&quot;</span>,today,today,today);</span><br><span class="line"><span class="comment">// 以下可以不用重复输入参数</span></span><br><span class="line"><span class="comment">// String s = String.format(&quot;%tA, %&lt;tB %&lt;td&quot;,today);</span></span><br><span class="line"><span class="comment">// &lt; 代表重复利用之前的参数</span></span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">// OP 星期一, 三月 08</span></span><br></pre></td></tr></table></figure>
<code>java.util.Calendar</code>操作日期<br>Calendar是个抽象类，不能创建它的实例，但是可以取得它具体子类的实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calendar cal &#x3D; Calendar.getInstance();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="非静态内部类不能拥有静态成员"><a href="#非静态内部类不能拥有静态成员" class="headerlink" title="非静态内部类不能拥有静态成员"></a>非静态内部类不能拥有静态成员</h4><p><a href="https://www.cnblogs.com/lulu638/p/4033581.html">参考</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Head First Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_myHash</title>
    <url>/2021/03/17/LeetCode-myHash/</url>
    <content><![CDATA[<h3 id="Design-HashSet-and-HashMap"><a href="#Design-HashSet-and-HashMap" class="headerlink" title="Design HashSet and HashMap"></a>Design HashSet and HashMap</h3><p>做了LeetCode的705和706，Design HashSet和Design HashMap，主要是参考的答案。通过这两题的练习，对哈希有了初步的认识，也用Java自定义实现了链表结构。</p>
<span id="more"></span>
<h3 id="LeetCode-705"><a href="#LeetCode-705" class="headerlink" title="LeetCode 705"></a>LeetCode 705</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Design a HashSet without using any built-in hash table libraries.</p>
<p>Implement MyHashSet class:</p>
<ul>
<li>void add(key) Inserts the value key into the HashSet.</li>
<li>bool contains(key) Returns whether the value key exists in the HashSet or not.</li>
<li>void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-hashset">https://leetcode-cn.com/problems/design-hashset</a></p>
<h4 id="提交的代码"><a href="#提交的代码" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution705_SeparateChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASHNUM=<span class="number">10009</span>;</span><br><span class="line">    Node[] hashset = <span class="keyword">new</span> Node[HASHNUM];</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key%HASHNUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = hash(key);</span><br><span class="line">        Node pointer=hashset[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = pointer;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer = prev;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">            pointer.next = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashset[idx] = <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = hash(key);</span><br><span class="line">        Node pointer = hashset[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = pointer.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hashset[idx] = pointer.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = pointer;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = hash(key);</span><br><span class="line">        Node pointer = hashset[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考题解：<a href="https://leetcode-cn.com/problems/design-hashset/solution/yi-ti-san-jie-jian-dan-shu-zu-lian-biao-nj3dg/">一题三解：「简单数组」&amp;「链表」&amp; 「分桶数组」</a></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>咩系哈希<br> 记在了计算机基础零碎记录里面，实现上有两点，一点是哈希函数的选取，一点是解决哈希冲突方法的选取。</li>
<li>哈希函数的选取<br>705我直接用的是最简单的取余，除数要用质数，参考的题解是这样写的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 nodes 的长度只有 10009，对应的十进制的 10011100011001（总长度为 32 位，其余高位都是 0）</span></span><br><span class="line"><span class="comment">// 为了让 key 对应的 hash 高位也参与运算，这里对 hashCode 进行右移异或</span></span><br><span class="line"><span class="comment">// 使得 hashCode 的高位随机性和低位随机性都能体现在低 16 位中</span></span><br><span class="line"><span class="keyword">int</span> hash = Integer.hashCode(key);</span><br><span class="line">hash ^= (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">return</span> hash % nodes.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了减少碰撞，进一步降低hash冲突的几率。int类型的数值是4个字节的，右移16位异或可以同时保留高16位于低16位的特征。<br>总之就是增大随机性，降低碰撞的概率。这一点处理可以记住。<br>此处还延伸的知识点就是位运算，但是我懒得写了。。。<br>参考：<a href="https://www.jianshu.com/p/6794168e3a5f">hash为什么要右移16位异或？</a></li>
<li>处理哈希冲突<br>采用链式地址法:当未发生冲突时，则直接存放该数据元素；当冲突产生时，把产生冲突的数据元素另外存放在单链表中。<br>在这道题的实现里，还有头插和尾插，用的是尾插。</li>
</ul>
<h3 id="LeetCode-706"><a href="#LeetCode-706" class="headerlink" title="LeetCode 706"></a>LeetCode 706</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>Design a HashMap without using any built-in hash table libraries.</p>
<p>Implement the MyHashMap class:</p>
<ul>
<li>MyHashMap() initializes the object with an empty map.</li>
<li>void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.</li>
<li>int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</li>
<li>void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-hashmap">https://leetcode-cn.com/problems/design-hashmap</a></p>
<h4 id="提交的代码-1"><a href="#提交的代码-1" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myHashMap</span> </span>&#123;</span><br><span class="line">    Node[] nodes = <span class="keyword">new</span> Node[<span class="number">10009</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key,value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashcode = Integer.hashCode(key);</span><br><span class="line">        hashcode ^= (hashcode &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> hashcode % nodes.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = getIndex(key);</span><br><span class="line">        Node pointer = nodes[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    pointer.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = pointer;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer = prev;</span><br><span class="line">            pointer.next = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">            <span class="comment">// 疑惑：为什么这边不能直接写成</span></span><br><span class="line">            <span class="comment">// pointer = new Node(key.value);</span></span><br><span class="line">            <span class="comment">// 明明pointer指向最后一个不为null元素的next，直接赋给这个next不也连在一起吗</span></span><br><span class="line">            <span class="comment">// 懂了 脑子进水</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodes[idx] = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = getIndex(key);</span><br><span class="line">        Node pointer = nodes[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pointer.value;</span><br><span class="line">                &#125;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = getIndex(key);</span><br><span class="line">        Node pointer = nodes[idx];</span><br><span class="line">        <span class="keyword">if</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (pointer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer.key == key) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = pointer.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nodes[idx] = pointer.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = pointer;</span><br><span class="line">                pointer = pointer.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><p>这道和705差不多，只不过多了个value，写法上基本一模一样，有个地方脑子抽风，写在注释里了。大概就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> key) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node aNode = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        aNode.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node ptr = aNode;</span><br><span class="line">        ptr = ptr.next;  <span class="comment">// 这里ptr指向的是aNode的next</span></span><br><span class="line">        System.out.println(ptr.key);</span><br><span class="line">        ptr = <span class="keyword">new</span> Node(<span class="number">3</span>);  <span class="comment">// 这里ptr指向另外一个对象了，和aNode的next没关系了</span></span><br><span class="line">        System.out.println(aNode.next.key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表现出基本功不扎实，还需努力。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Java</tag>
        <tag>计算机技术</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode笔记--数学类</title>
    <url>/2021/03/07/LeetCode%E6%95%B0%E5%AD%A6%E7%B1%BB/</url>
    <content><![CDATA[<p>这是LeetCode分类的第一篇记录，之所以称之为记录而不是文章是因为自觉这里面原创的内容并不多，只是做题家的错题集，对着别人写的答案写一遍并记录下知识点，仅此而已。  </p>
<span id="more"></span>
<p>刷LeetCode还是蛮为难的，因为计算机基础薄弱，没有学过数据结构和算法，现在也没时间进行系统性的学习，所以只能摸着石头过河，先尽量刷着，之后再说。<br>所以目前先做一些easy的不需要用到或者少用到数据结构和算法知识的题目，主要是熟悉Java语言特性，也为后期的学习铺垫。<br>不积跬步无以至千里，期待我主动分享自己独特题解的一天。</p>
<h3 id="LeetCode007"><a href="#LeetCode007" class="headerlink" title="LeetCode007"></a>LeetCode007</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31-1] ，就返回 0。<br><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong>  </p>
<p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31-1], then return 0.<br><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>
<h4 id="提交的代码"><a href="#提交的代码" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            a = a * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; Integer.MAX_VALUE || a &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>题目中强调了不允许储存64位整数，所以不能出现long型整数，那么需要在溢出前判断。需要注意的点在于要在<code>a = a * 10 + x % 10;</code>前判断赋值后的<code>a</code>是否溢出。</p>
<ul>
<li>方法一<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE / <span class="number">10</span> || </span><br><span class="line">        (rev == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &gt; Integer.MAX_VALUE%<span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="number">10</span> ||</span><br><span class="line">        (rev == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &lt; Integer.MIN_VALUE%<span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rev = rev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rev * <span class="number">10</span>) / <span class="number">10</span> != rev) &#123;</span><br><span class="line">            rev = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rev = rev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
知识点：用<code>(rev*10)/10 != rev</code>判断溢出，是因为Java里int溢出时是会发生数值紊乱的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> intmax = Integer.MAX_VALUE;</span><br><span class="line">System.out.println(intmax+<span class="number">1</span>-Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
这里<code>rev*10</code>不溢出，那么在此题的情景下<code>rev*10+x%10</code>也不会溢出，因为如果要加上<code>x%10</code>溢出的话<code>x%10</code>要大于7或者小于-8，但是<code>x</code>是int，所以不存在这种情况，总之这是一个挺好的小技巧。</li>
</ul>
<h3 id="LeetCode-008"><a href="#LeetCode-008" class="headerlink" title="LeetCode 008"></a>LeetCode 008</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<br>函数 myAtoi(string s) 的算法如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。  </li>
<li>返回整数作为最终结果。</li>
</ul>
<h4 id="提交的代码-1"><a href="#提交的代码-1" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution008</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (charArray[index] == <span class="string">&#x27; &#x27;</span> &amp;&amp; index &lt; len) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> firstChar = charArray[index];</span><br><span class="line">        <span class="keyword">if</span> (firstChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> currChar = charArray[index];</span><br><span class="line">            <span class="keyword">if</span> (currChar &gt; <span class="string">&#x27;9&#x27;</span> || currChar &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">&#x27;0&#x27;</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE/<span class="number">10</span> || res == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; (<span class="string">&#x27;0&#x27;</span>- currChar) &lt; Integer.MIN_VALUE % <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + (currChar - <span class="string">&#x27;0&#x27;</span>) * sign;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution008 solution008 = <span class="keyword">new</span> Solution008();</span><br><span class="line">        String str = <span class="string">&quot;-2147483649&quot;</span>;</span><br><span class="line">        System.out.println(solution008.myAtoi(str));</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul>
<li>用什么数据结构<br>这里使用的是字符数组，使用String类的<code>toCharArray()</code>方法把字符串转化为字符数组  </li>
<li>如何保证不溢出（在只储存32的环境下）<br>这里和007题有相似之处，都是在进位相加前判断是否溢出，这里的处理需要更加细腻。</li>
<li>这题在处理溢出时有个和007不同的地方，我一开始做的时候准备直接忽略正负，判断绝对值，这样是不对的，因为Integer.MAX_VALUE和Integer.MIN_VALUE的绝对值并不相同。我提交多次在于没有处理好负数的情况。007那题在判断下限是否溢出时那个余数不需要考虑正负，但是这题用的是<code>currchar-&#39;0&#39;</code>这就需要把它变成负的再比较。</li>
<li>细节处理上需要记住的就是<code>currchar-&#39;0&#39;</code>和<code>currchar &gt; &#39;9&#39; || currchar &lt; &#39;0&#39;</code>,前者用来判断数字字符代表的数字，后者用来判断字符是否为数字字符。</li>
</ul>
<h3 id="Leetcode-009"><a href="#Leetcode-009" class="headerlink" title="Leetcode 009"></a>Leetcode 009</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p>
<h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p>我的思路：剔除负数后把数字放进数组里比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution009</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; lst = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            lst.add(x % <span class="number">10</span>);</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(lst);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (lst.size() / <span class="number">2</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst.get(i) != lst.get(lst.size() - i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution009 solution009 = <span class="keyword">new</span> Solution009();</span><br><span class="line">        System.out.println(solution009.isPalindrome(<span class="number">1210</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>如果不用数组，我想到的方法就是直接把数字倒过来看和原来的是不是相等，但是其实可以不用这样，可以只比较一半，也就是位数为偶数位时只比较一半，奇数位时比较除去中间那位的两边，难点在于这个取一半的点在哪里。<br>此处在取反转的数的时候，用的方法和007一样，就是一步步求余数，但是如何判断到达一半了呢？<br>官方题解给了一个很妙的<code>门</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-1512"><a href="#Leetcode-1512" class="headerlink" title="Leetcode 1512"></a>Leetcode 1512</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>Given an array of integers nums.<br>A pair (i,j) is called good if nums[i] == nums[j] and i &lt; j.<br>Return the number of good pairs.</p>
<h4 id="提交的代码-2"><a href="#提交的代码-2" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1512</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pairs = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.containsKey(i)) &#123;</span><br><span class="line">                hm.put(i, hm.get(i) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hm.put(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : hm.keySet()) &#123;</span><br><span class="line">            pairs += hm.get(key) * (hm.get(key) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution1512 solution1512 = <span class="keyword">new</span> Solution1512();</span><br><span class="line">        Optimization1512 optimization1512 = <span class="keyword">new</span> Optimization1512();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution1512.numIdenticalPairs(nums));</span><br><span class="line">        System.out.println(optimization1512.numIdenticalPairs(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h4><h5 id="针对我自己解法写法上的优化"><a href="#针对我自己解法写法上的优化" class="headerlink" title="针对我自己解法写法上的优化"></a>针对我自己解法写法上的优化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Optimization1512</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pairs = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            hm.put(i, hm.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : hm.entrySet()) &#123;</span><br><span class="line">            pairs += entry.getValue() * (entry.getValue() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学习的点</p>
<ul>
<li><code>hm.put(i, hm.getOrDefault(i, 0) + 1);</code><br>这里运用的是<code>getOrDefualt()</code>方法，语法为<code>hashmap.get(Object key, V defaultValue)</code>，如果<code>key</code>存在，返回对应的<code>value</code>，如果<code>key</code>不存在，返回写入的默认值。<code>put</code>组合<code>getOrDefault</code>这个写法非常适合用于hashmap的元素添加。</li>
<li><code>HashMap</code>的遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;key is &quot;</span>+entry.getKey());</span><br><span class="line">System.out.println(<span class="string">&quot;value is &quot;</span>+ entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="别人的优解"><a href="#别人的优解" class="headerlink" title="别人的优解"></a>别人的优解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为 1&lt;= nums[i] &lt;= 100  所以申请大小为100的数组</span></span><br><span class="line">        <span class="comment">//temp用来记录num的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从前面开始遍历nums</span></span><br><span class="line"><span class="comment">        假设nums = [1,1,1,1]</span></span><br><span class="line"><span class="comment">        第一遍</span></span><br><span class="line"><span class="comment">        temp是[0,0,0,0]</span></span><br><span class="line"><span class="comment">        ans+=0;</span></span><br><span class="line"><span class="comment">        temp[0]++;</span></span><br><span class="line"><span class="comment">        第二遍</span></span><br><span class="line"><span class="comment">        temp是[1,0,0,0]</span></span><br><span class="line"><span class="comment">        ans+=1;</span></span><br><span class="line"><span class="comment">        temp[0]++;</span></span><br><span class="line"><span class="comment">        第三遍</span></span><br><span class="line"><span class="comment">        temp=[2,0,0,0]</span></span><br><span class="line"><span class="comment">        ans+=2;</span></span><br><span class="line"><span class="comment">        temp[0]++;</span></span><br><span class="line"><span class="comment">        第四遍</span></span><br><span class="line"><span class="comment">        temp=[3,0,0,0]</span></span><br><span class="line"><span class="comment">        ans+=3;</span></span><br><span class="line"><span class="comment">        temp[0]++;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这行代码可以写成</span></span><br><span class="line"><span class="comment">            ans+=temp[num - 1];</span></span><br><span class="line"><span class="comment">            temp[num - 1]++;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            ans += temp[num - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：JayceonDu</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/number-of-good-pairs/solution/zhe-gu-ji-shi-wo-xie-zen-yao-duo-ti-yi-lai-zui-dua/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/</span></span><br></pre></td></tr></table></figure>
我直呼好家伙</li>
</ul>
<h3 id="Leetcode-069"><a href="#Leetcode-069" class="headerlink" title="Leetcode 069"></a>Leetcode 069</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h4 id="提交的代码-3"><a href="#提交的代码-3" class="headerlink" title="提交的代码"></a>提交的代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution069</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 我算了下x&gt;=4之后输出都小于x/2，46341是int上界的输出+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">46341</span> &amp; i &lt;= x / <span class="number">2</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>)i * i &gt;= x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">long</span>)i * i == x) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>多么朴实无华的思路，一颗空空荡荡不知算法为何物的脑袋。</p>
<h4 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h4><h5 id="二分法写法"><a href="#二分法写法" class="headerlink" title="二分法写法"></a>二分法写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Optimization069</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=x,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;  <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid&gt;x)&#123;  <span class="comment">// 防止溢出</span></span><br><span class="line">                ans=mid-<span class="number">1</span>;</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span>)mid*mid &lt;x)&#123;  <span class="comment">// 防止溢出</span></span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>坑，未填。</p>
<h5 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h5><ul>
<li>一个是mid那里，把<code>mid = (l+r)/2</code>写成<code>mid = l +(r-l)/2</code>可以防止溢出</li>
<li>在判断当前数字平方是否大于x时，也要防止溢出，<code>(long)mid*mid &gt; x</code></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Java</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-回溯法小结</title>
    <url>/2021/05/12/LeetCode-%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>一开始接触回溯法觉得大脑爆频了，做了入门级的题目稍微有了一些感觉，总结一下。</p>
<span id="more"></span>
<h3 id="LeetCode-78"><a href="#LeetCode-78" class="headerlink" title="LeetCode 78"></a>LeetCode 78</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<p>来源：<a href="https://leetcode-cn.com/problems/subsets">https://leetcode-cn.com/problems/subsets</a></p>
<h4 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt;= nums.length; len++) &#123;</span><br><span class="line">            backtrack(nums, len, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  backtrack()的作用是把数组nums里所有长度为subsetLen的子集加入结果subsets里面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> subsetLen, List&lt;Integer&gt; subset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subsetLen == <span class="number">0</span>) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(subset));</span><br><span class="line">            <span class="comment">//subsets.add(subset);   这种写法就是错的，subsets里所有元素都指向subset后面会改变的。</span></span><br><span class="line">            <span class="comment">// 把当前子集加入结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                subset.add(nums[i]);</span><br><span class="line">                backtrack(Arrays.copyOfRange(nums, i + <span class="number">1</span>, nums.length), subsetLen - <span class="number">1</span>, subset);</span><br><span class="line">                <span class="comment">// Arrays.copyOfRange(nums,i+1,nums.length)是nums当前元素之后的部分，</span></span><br><span class="line">                <span class="comment">// 把后面这部分里所有长度为subsetLen-1的子集加入结果</span></span><br><span class="line">                subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯，删除当前元素，开始当前位置其余元素的遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之后又写了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] _nums) &#123;</span><br><span class="line">        nums = _nums;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 加入不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            backtrack(i,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在curr中加入从nums[start]开始(包括)、长度为len的子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len  要生成子集的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  开始遍历的结点索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curr  子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> start, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小小的剪枝：i &lt;= nums.length - len</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= nums.length - len; i++) &#123;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            backtrack(len - <span class="number">1</span>, i + <span class="number">1</span>, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又写了一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] _nums) &#123;</span><br><span class="line">        nums = _nums;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 加入不同长度的子集</span></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start,List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不选当前结点，直接进行下一步搜索</span></span><br><span class="line">        dfs(start + <span class="number">1</span>, curr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选择当前结点，进行下一步处理后再撤回</span></span><br><span class="line">        curr.add(nums[start]);</span><br><span class="line">        dfs(start + <span class="number">1</span>, curr);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>回溯处理子集类的问题，思路：选中当前元素–下一步处理–撤销当前元素。<br>先看写法一和写法二，这两种思路一致，细节处理不一样而已。<br>当我要得到长度为len的子集时，子集的第一个元素有很多选择，那么我依次遍历一遍，所以用的for循环。循环一开始，先选中数组第一个元素，加入子集，然后再加入第一个元素之后所有长度为len-1的子集就可以了，然后撤回一开始的选择-选择第一个元素。因为是无重复元素的子集，所以之后就与这个第一个元素无关了，带有它的所有子集都已经加入结果了，直接考虑之后的部分就好了。所以写法一里面我当时直接生成了当前元素之后的部分的数组带进下一个位置的遍历。<br>这里面每一层循环都代表子集里当前位置的选择，选择一个元素后进入下一层backtrack选择下一个位置的选择，这个深度和生成子集的长度有关。<br>写法一是直接复制一个新的数组，写法二是直接考虑开始遍历的元素索引，写法二更普遍与节约空间一些。我一开始有点想不通就是为什么写法二里面是<code>backtrack(len - 1, i + 1, curr);</code>,就是因为还没弄明白这一层for循环结束后，就和当前元素这位兄弟say byebye了，和他有关的事情都已经安排的明明白白了，只需要考虑之后兄弟的事情就好了。<br>写法三是看了题解后学到的，十分简单易懂，方法一二的深度和生成子集的长度有关，那么写法三就是和结点数量有关。写法三就是挨个问每一个结点，这个项目你加不加入？不加入，那我们处理你不加入的情况，之后dfs()所加入的结果都是不带这位大哥的结果。加入，我们就处理加入的情况，之后dfs()后的结果都是带这位大哥参加的结果，然后撤回这个选择。</p>
<h4 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a>模板一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="comment">// 在最终结果里加入curr</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; ...... ) &#123;</span><br><span class="line">        curr.add();  </span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr);</span><br><span class="line">        curr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最终结果里加入curr</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不选择</span></span><br><span class="line">    dfs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    curr.add();</span><br><span class="line">    dfs();</span><br><span class="line">    curr.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般回溯函数的变量包含三个：</p>
<ul>
<li>处理元素的位置</li>
<li>要达成的某个目标</li>
<li>盛放进行中结果的数据结构 </li>
</ul>
<h3 id="LeetCode17"><a href="#LeetCode17" class="headerlink" title="LeetCode17"></a>LeetCode17</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>来源：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a></p>
<h4 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> String digits;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String _digits)</span> </span>&#123;</span><br><span class="line">        digits = _digits;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>,<span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, StringBuffer curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.length() == digits.length()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> StringBuffer(curr).toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String currDigits = map.get(digits.charAt(idx));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currDigits.length(); i++) &#123;</span><br><span class="line">            curr.append(currDigits.charAt(i));</span><br><span class="line">            backtrack(idx + <span class="number">1</span>, curr);</span><br><span class="line">            curr.deleteCharAt(curr.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>这道题十分模板，是用回溯处理子集的问题。大体思路就是遍历所有可能的元素，先加入这个元素，进行下一步处理，处理完成后加入结果，然后再撤回这个这个元素，尝试下一个元素。这道题是最简单的，因为是遍历所有可能的组合，所以直接无脑for循环。<br>细节上，用<code>HashMap</code>储存数字对应的字母，然后<code>String</code>用的是<code>StringBuffer.toString()</code>，这样效率更高。</p>
<h3 id="LeetCode-39"><a href="#LeetCode-39" class="headerlink" title="LeetCode 39"></a>LeetCode 39</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
<p>来源：<a href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a></p>
<h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>这道题和之前有个不一样就是：这道题元素是可重复的。<br>模板一的思路是安排完当前元素就不用再考虑带这个元素的方案了，但是这道题一个元素可以被使用多回，如果在for循环里不加限制，只是单纯判断是否需要加进去，那么最后的输出会出现冗余。<br>比如：candidates = [1,2,3]  target = 8<br>输出会出现[2,2,3] [2,3,2] [3,2,2]<br>这就是按位置考虑选择的结果。所以我在加入结果时进行判断。<br>如何对<code>[2,2,3] [2,3,2] [3,2,2]</code>去重呢？因为不要求顺序，所以先排序，然后用<code>set</code>去重。这里要注意排序时不能直接拿curr排序，不然会影响之后撤回结果，需要深拷贝，别问我怎么知道的。<br>这道题比较适合用模板二，用模板二不需要考虑重复的问题，其中做了一点剪枝，结果还不错，直接看代码有注释。</p>
<h4 id="My-Codes"><a href="#My-Codes" class="headerlink" title="My Codes"></a>My Codes</h4><p>模板一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] _candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        candidates = _candidates;</span><br><span class="line">        ans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        backtrack(<span class="keyword">new</span> ArrayList&lt;&gt;(),target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; curr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(curr);</span><br><span class="line">            copy.sort(Comparator.naturalOrder());</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(copy));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                backtrack(curr, target - candidates[i]);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] _candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        candidates = _candidates;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : candidates) &#123;</span><br><span class="line">            min = Math.min(min, i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 当前搜索的目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  搜索结点时起点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curr  当前子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝 如果target小于candidates里数字的最小值那么停止搜索</span></span><br><span class="line">        <span class="keyword">if</span> (start == candidates.length || (target &lt; min &amp;&amp; target &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有选择当前结点，那么之后也不用选择，不然会产生冗余</span></span><br><span class="line">        dfs(target, start + <span class="number">1</span>, curr);</span><br><span class="line">        <span class="comment">// 选择了当前结点，深入搜索</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[start] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curr.add(candidates[start]);</span><br><span class="line">            dfs(target - candidates[start], start, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-1723"><a href="#LeetCode-1723" class="headerlink" title="LeetCode 1723"></a>LeetCode 1723</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job.</p>
<p>There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.</p>
<p>Return the minimum possible maximum working time of any assignment. </p>
<p>来源：<a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs">https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs</a></p>
<h4 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] jobs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] _jobs, <span class="keyword">int</span> _k)</span> </span>&#123;</span><br><span class="line">        jobs = _jobs;</span><br><span class="line">        k = _k;</span><br><span class="line">        len = jobs.length;</span><br><span class="line">        Arrays.sort(jobs);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = jobs.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            temp = jobs[i];</span><br><span class="line">            jobs[i] = jobs[j];</span><br><span class="line">            jobs[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = jobs[<span class="number">0</span>], r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : jobs) &#123;</span><br><span class="line">            r += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] workloads = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">return</span> backtrack(limit, <span class="number">0</span>, workloads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> nextJob, <span class="keyword">int</span>[] workloads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextJob == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = jobs[nextJob];</span><br><span class="line">            <span class="keyword">if</span> (workloads[i] + curr &lt;= limit) &#123;</span><br><span class="line">                workloads[i] += curr;</span><br><span class="line">                <span class="keyword">if</span> (backtrack(limit, nextJob + <span class="number">1</span>, workloads)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                workloads[i] -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workloads[i] == <span class="number">0</span> || workloads[i] + curr == limit) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>这道题我的做法是二分+回溯，当时大概思路是有的，但是无从下手，看了别人的代码发现别人的回溯带了返回，这和我之前的就很不一样，我之前写的都是<code>void</code>。那么回顾一下这一题，首先大体思路是二分法，左边界是单项工作最大的工作量，右边界是所有工作量之和，在这里面不断check当前是否符合条件，经典的寻找符合条件的最小值。<br>那么比较重要的就是这个check函数怎么写，我们知道check的目标是判断是否存在一种方案使工人在需要判断的时间里完成工作。那么在方案的选择上就可以用到回溯。<br>那么怎么用这个回溯呢，因为是方案的判定，所以建立一个数组盛放这个方案也就是<code>int[] workloads;</code>，记录的是每个工人的工作量。<br>在上面我有写过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般回溯函数的变量包含三个：</span><br><span class="line">  - 处理元素的位置</span><br><span class="line">  - 要达成的某个目标</span><br><span class="line">  - 盛放进行中结果的数据结构 </span><br></pre></td></tr></table></figure>
<p>这道题里面：</p>
<ul>
<li>处理元素的位置：int nextJob</li>
<li>要达成的某个目标：int limit</li>
<li>盛放结果的数据：int[] workloads</li>
</ul>
<p>for循环是遍历每一个工人，如果符合条件：把当前工作给这个工人–处理这个方案下后一项工作的安排，判断这个方案是否可行。这里面因为不是void不会自动加入结果所以需要层层返回判断，如果下一层返回了true说明当前这个选择是可以的，那么就可以返回true。<br>需要注意的是因为这道题不是为了遍历所有可能的方案，所以如果一个方案可行，就不需要撤回操作。<br>优化：</p>
<ul>
<li>如果当前工人没有安排工作，那么就终止这个遍历，因为安排给之后某个工人也不会找到方案，工人一与工人二无异。</li>
<li>如果当前工人工作量正好达到limit但是之后没有可行方案，那么也退出。这个剪枝十分巧妙，属于打死我也不可能想到的类型，可以用反证法进行证明。<br>总之困难题真的好困难哦呜呜呜……</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>题量破百</title>
    <url>/2021/05/14/%E9%A2%98%E9%87%8F%E7%A0%B4%E7%99%BE/</url>
    <content><![CDATA[<p>热烈庆祝本博主力扣刷题量过百，持续做出了一些微小的努力，未来可期！</p>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术笔记 第6章 接口、lambda表达式和内部类</title>
    <url>/2021/05/21/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>学习记录</p>
<span id="more"></span>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h4><p>接口的概念我觉得还是Head First Java里面讲的比较清楚：<br><code>部分类需要具体实现某些方法，如果定义在父类里作为抽象方法，那么不需要执行这个方法的子类也要具体实现这个抽象方法造成浪费，所以最好就是创造出类似于多重继承的关系，但是Java是不支持多重继承的，所以有接口这个概念。</code></p>
<ul>
<li>接口不是类:<code>A Java Interface is like a 100% pure abstract class.</code></li>
</ul>
<h4 id="接口属性"><a href="#接口属性" class="headerlink" title="接口属性"></a>接口属性</h4><ul>
<li>不能通过<code>new</code>实例化接口，可以声明接口变量，引用实现了这个接口的类的对象。</li>
<li>**接口里所有方法都自动是<code>public</code>方法，接口中的字段都是<code>public static final</code>**，在接口说明方法时不必提供关键字<code>public</code>，但是在实现接口时必须把方法声明为<code>public</code>，否则编译器将认为这个方法的访问属性是包可见性，这是类的默认访问属性。</li>
<li>JAva 9中，接口中的方法可以是<code>private</code>，<code>private</code>方法可以是静态或者实例方法，仅限于接口本身方法使用，作为接口中其它方法的辅助方法。</li>
</ul>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>讲Java不像C++支持多重继承，所以会有接口的存在，一个类只能有一个超类，但是可以实现多个接口。</p>
<h4 id="静态和私有方法"><a href="#静态和私有方法" class="headerlink" title="静态和私有方法"></a>静态和私有方法</h4><p>在Java 8中，允许在接口中增加静态方法，但是这有违于接口作为抽象规范的初衷。所以通常做法是将静态方法放在伴随类里面：<code>Collection</code>和<code>Collections</code>、<code>Path</code>和<code>Paths</code>。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法为接口提供一个默认实现，必须用<code>default</code>修饰符标记这样的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认方法的一个重要用法是<code>接口演化</code>。</p>
<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>先在一个接口中一个方法定义为默认方法，然后又在超类或者另一个接口中定义同样的方法，规则如下：  </p>
<ul>
<li><code>超类优先,在同名、相同参数类型下</code>。这正是<strong>类优先</strong>原则。</li>
<li>如果一个接口提供了默认方法，另一个接口提供了同名且参数类型相同的方法，<code>必须覆盖这个方法解决冲突</code>。  书上的例子是这样的：   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+<span class="string">&quot;_&quot;</span>+hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">Name</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
  这种情况下会报错，需要在两个冲突方法中选择一个。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
关于<strong>类优先</strong>原则的Tip：不要让一个默认方法重新定义<code>Object</code>类中的某个方法，因为类优先原则决定了这样的方法无法超越Object的方法。</li>
</ul>
<h4 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h4><p>书上这部分讲得对新手很不友好，我看的这篇博客一目了然。<br><a href="https://blog.csdn.net/qq_43137699/article/details/111181206">案例-接口回调</a></p>
<h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h4><p>练习：实现一个字符串比较器–根据字符串长度排序，相同长度按照字典顺序。</p>
<blockquote>
<p>Arrays.sort()方法可以将数组和一个比较器的实例作为参数，实现自定义的数组排序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) - <span class="string">&#x27;a&#x27;</span> != s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.charAt(i) - <span class="string">&#x27;a&#x27;</span> - (s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;paul&quot;</span>, <span class="string">&quot;mary&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> LengthComparator());</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            System.out.println(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>问题：如果对象包含子对象的引用，拷贝字段就会得到相同子对象的另一个引用，这样原对象和克隆的对象仍然会共享一些信息。</p>
<ul>
<li>如果原对象和浅克隆的对象共享的子对象不可变（比如String）那么这种共享是安全的。</li>
<li>在对象的生命期中，子对象一直包含不变的常量，没有更改器方法改变它，也没有方法生成其引用，这种情况同样安全。</li>
</ul>
<p>解决：通常子对象可变，所以需要重新定义<code>clone()</code>建立深拷贝，克隆所有子对象，**并且必须重新定义的<code>clone()</code>修饰为<code>public</code>**。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><blockquote>
<p>通常格式：<code>()-&gt;&#123;&#125;</code><br>必须包含显式的return语句</p>
</blockquote>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>Java有很多封装代码块的接口，比如<code>Comparator</code>、<code>ActionListener</code>等，lambda表达式与这些接口兼容。对于只有一种抽象方法的接口，就可以提供一个lambda表达式，这种接口称为<code>函数式接口</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(words,(a,b)-&gt;a.length()-b.length())</span><br></pre></td></tr></table></figure>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><blockquote>
<ul>
<li>object::instanceMethod<br>这种情况方法引用等价于向方法传递参数的lambda表达式<br>比如<code>System.out::printly</code>，<code>System.out</code>是对象，方法表达式约等于<code>x-&gt;System.out.println(x)</code>。</li>
<li>Class::instanceMethod<br>这种情况第一个参数会成为方法的隐式参数，<code>String::compareToIgnoreCase</code>相当于<code>(x,y)-&gt;x.compareToIgnoreCase(y)</code>。</li>
<li>Class::staticMethod<br>这种情况，所有参数都传递到静态方法中</li>
</ul>
</blockquote>
<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>栗子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">People[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li>lambda可以捕获外围作用域中变量的值，但是<strong>只能引用值不会改变的变量。</strong><br>这种限制是有原因的，比如并发执行多个动作时引用了改变的量那么就是不安全的。</li>
</ul>
<p><strong>lambda表达式捕获的变量必须是事实最终变量</strong>，也就是这个变量初始化之后不能再赋新值。</p>
<ul>
<li>lambda中不能有同名的局部变量</li>
</ul>
<h4 id="Comparator与方法引用"><a href="#Comparator与方法引用" class="headerlink" title="Comparator与方法引用"></a>Comparator与方法引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(people,Comparator.comparing(Person::getName));</span><br><span class="line">Arrays.sort(people,Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName));</span><br></pre></td></tr></table></figure>
<p><code>Comparator.comparing()</code>可以有两个参数，第一个是提取sort key的函数，第二个是比较器。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Java核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组的判断相等</title>
    <url>/2021/06/10/Java%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<p>前几天做题发现一个关于判断数组相等的问题，这里记录一下。</p>
<span id="more"></span>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当时我需要判断两个<code>int[][]</code>变量是否相等，我以为简单地<code>equals</code>一下就好了，然而并不是这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">equalsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] t1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] t2 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.equals(t1, t2));</span><br><span class="line">        System.out.println(t1.equals(t2));</span><br><span class="line">        <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.equals(a1, a2));</span><br><span class="line">        System.out.println(a1.equals(a2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>false<br>  false<br>  true<br>  false</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="a1-equals-a2"><a href="#a1-equals-a2" class="headerlink" title="a1.equals(a2)"></a><code>a1.equals(a2)</code></h4><p><code>a1</code>和<code>a2</code>是<code>int[]</code>类型，这个比较简单，查看源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显<code>a1 == a2</code>是<code>false</code>，并不能用<code>Object.equals()</code>判断数组内容相等。</p>
<h4 id="Arrays-equals-a1-a2"><a href="#Arrays-equals-a1-a2" class="headerlink" title="Arrays.equals(a1,a2)"></a><code>Arrays.equals(a1,a2)</code></h4><p><code>a1</code>和<code>a2</code>是<code>int[]</code>类型，查看源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the two specified arrays of ints are</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both</span></span><br><span class="line"><span class="comment"> * arrays contain the same number of elements, and all corresponding pairs</span></span><br><span class="line"><span class="comment"> * of elements in the two arrays are equal.  In other words, two arrays</span></span><br><span class="line"><span class="comment"> * are equal if they contain the same elements in the same order.  Also,</span></span><br><span class="line"><span class="comment"> * two array references are considered equal if both are &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a one array to be tested for equality</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a2 the other array to be tested for equality</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the two arrays are equal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="keyword">null</span> || a2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ArraysSupport.mismatch(a, a2, length) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面是一些特判，到最后用的是<code>return ArraysSupport.mismatch(a, a2, length) &lt; 0;</code>，再去查看这个<code>ArraysSupport.mismatch();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the relative index of a mismatch between two arrays starting from</span></span><br><span class="line"><span class="comment">     * given indexes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not perform bounds checks. It is the responsibility</span></span><br><span class="line"><span class="comment">     * of the caller to perform such bounds checks before calling this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the first array to be tested for a mismatch</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aFromIndex the index of the first element (inclusive) in the first</span></span><br><span class="line"><span class="comment">     * array to be compared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b the second array to be tested for a mismatch</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bFromIndex the index of the first element (inclusive) in the</span></span><br><span class="line"><span class="comment">     * second array to be compared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the number of bytes from each array to check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the relative index of a mismatch between the two arrays,</span></span><br><span class="line"><span class="comment">     * otherwise -1 if no mismatch.  The index will be within the range of</span></span><br><span class="line"><span class="comment">     * (inclusive) 0 to (exclusive) the smaller of the two array bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ints</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mismatch</span><span class="params">(<span class="keyword">int</span>[] a,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span>[] b,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            i = vectorizedMismatch(</span><br><span class="line">                    a, Unsafe.ARRAY_INT_BASE_OFFSET,</span><br><span class="line">                    b, Unsafe.ARRAY_INT_BASE_OFFSET,</span><br><span class="line">                    length, LOG2_ARRAY_INT_INDEX_SCALE);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            i = length - ~i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以就是如果两个<code>int[]</code>里面元素全部相等时返回<code>-1</code>，所以<code>Arrays.equals()</code>能够判断两个<code>int[]</code>是否内容相同。</p>
<h4 id="t1-equals-t2"><a href="#t1-equals-t2" class="headerlink" title="t1.equals(t2)"></a><code>t1.equals(t2)</code></h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以并不能够相等。</p>
<h4 id="Arrays-equals-t1-t2"><a href="#Arrays-equals-t1-t2" class="headerlink" title="Arrays.equals(t1, t2)"></a><code>Arrays.equals(t1, t2)</code></h4><p>这里<code>t1</code>和<code>t2</code>是<code>int[][]</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object[] a, Object[] a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="keyword">null</span> || a2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = a.length;</span><br><span class="line">    <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(a[i], a2[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以是用了<code>Objects.equals()</code>比较数组里的每个元素，这里数组里的元素是<code>int[]</code>，上面我们知道<code>Objects.equals()</code>无法判断<code>int[]</code>，所以<code>int[][]</code>也不行。  </p>
<p>反正最后用了一层循环挨个使用<code>Arrays.equals()</code>才判断了两个<code>int[][]</code>对象是否相等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
      </tags>
  </entry>
</search>
